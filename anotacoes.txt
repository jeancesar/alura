HTML e CSS 3 I
----------------------------------------------------
<main>: conteúdo principal da página
<header>: cabeçalho da página ou de uma região dela
<footer>: mesma ideia da tag <header> para o rodapé
<aside>: conteúdo auxiliar ao conteúdo principal, como links relacionados ao conteúdo
<article>: conteúdo que, por si só, já tem um sentido completo, como um post de um blog ou uma notícia
<section>: parte/seção de uma página ou texto
A Propriedade box-sizing do CSS ajuda a fazer o calculo automático de largura da "caixa" do elemento apartir de uma origem. Ex. bordas ou padding.
display: inline-block => ele deixa os elementos na horizontal e continua mantendo a opção de editar altura e largura.
ChromeVox => plugin para leitor de tela.
Clear => propriedade para fazer as limpezas de float dos elementos seguintes.
position: relative => mudar a posição do elemento de acordo com a posição original dele.
position: absolute => mudar a posição do elemento em relação a janela do navegador ou ao elemento pai quando ele tiver um position definido
Porcentagem são medidadas baseadas no elemento pai


Vimos, então, três novas medidas:
* rem: tem como padrão a fonte do navegador;
* em: tem como padrão a fonte do elemento pai;
* ch: tem como base a largura do caractere zero da fonte usada;
* Vimos que a porcentagem tem como base ou a largura do elemento pai ou o font-size do elemento anterior.

Javascript
----------------------------------------------------
"elemento.textContent" => Pega somente o conteudo de uma tag html
"document.getElementsByTagName("nome-da-tag")" => Obtem um array dos elementos da tag selecionada para pegar apenas o primeiro usar "[0]" no fim da função.
"document.getElementsByClassName("nome-da-class")" => Obtem um array dos elementos da class selecionada para pegar apenas o primeiro usar "[0]" no fim da função.
"document.getElementById("nome-do-id")" => Obtem o elemento selecionado pelo id.
"addEventListener("nome-do-evento","funcao-aqui")" => Outra maneira de chamar eventos em elementos html mas podendo chamar mais de um evento para o mesmo elemento.
"querySelector("seletor")" => Obtem o primeiro elemento do seletor passado por parâmetro (tag, .class, #id)
"querySelectorAll("seletor")" => Obtem um array do elemento do seletor passado por parâmetor (tag, .class, #id) 
"event.preventDefault();" => previne o comportamento padrão
"parseInt()" => convert uma valor numero em string para numero;
"Math.random()" => Sorteia um numero aleatorio com casa decimais.
"Math.round()" => Arredonda o número para cima.
"parseFloat()" => converte texto para decimal;
"Object.freeze(objeto)" => Converte um objeto para um estado imutavel não permitindo alterações ao longo do seu uso.
"Object.isFrozen(objeto)" => Testa se um determinado objeto está congelado ou não.
"let" => tipo de declaração de variavel que funciona para escopo em bloco.
"reduce()" => reduce, que todo array em JavaScript possui, inclusive desde a versão ES5. O retorno da função é um único valor, em nosso caso o total do volume. A função reduce recebe uma função como parâmetro e um valor. Na função, o primeiro parâmetro é a variável que receberá a soma do volume das nossas negociações. Já o segundo parâmetro nos dá acesso à negociação que estamos iterando no momento. Contudo, nosso código daria um erro, pois o primeiro parâmetro que receberá o total precisa ser inicializado. É por isso que o segundo parâmetro da função reduce é a inicialização desse valor, em nosso caso, começamos de 0.
"Reflect.apply" => A classe Reflect existe no ES2015 e aglutina diversas funções que nos auxiliam em metaprogramação. Usamos a função Reflect.apply, que recebe como primeiro parâmetro a função que queremos executar. 
O segundo parâmetro é o contexto no qual queremos que ela seja executada, ou seja, this._contexto passa a ser o this durante sua invocação.
"Arrow functions" => A palavra arrow, em português, significa flecha e uma arrow function utiliza => em sua declaração, o que lembra uma flecha. (item, outroitem) => item + outroitem;
Diferente das funções tradicionais, que possuem this dinâmico, as arrow functions possuem um this estático, isto é, ele não muda de acordo com o contexto da chamada da função e mantém o this no momento de sua declaração.
"(spread operator)" => https://developer.mozilla.org/pt-BR/docs/Web/JavaScript/Reference/Operators/Spread_operator
"arguments" => É uma variável implícita que nos dá acesso a todos os parâmetros passados para a função ou método.

DOM é um acrônimo para Document Object Model, basicamente ele é uma representação de uma página html no mundo Javascript e pode ser acessado a partir da variável document, que representa a raiz de nossa página.
Funções são estruturas que nos possibilitam isolar uma determinada lógica e dar um nome a ela, permitindo que a chamemos em vários pontos de nosso código! Elas ajudam muito organizar o nosso código e deixar ele mais legível.
Funções anônimas são funções que não recebem um nome para ser executadas.
É comum, quando estamos programando em Javascript, querer adicionar um comportamento ao clique de um elemento, ao usuário passar o mouse em cima de um elemento, quando o texto de um <input> for alterado e etc, estas ações são chamadas de eventos, que serão disparados em determinado momento.
Com Mixin podemos "pegar emprestado" o método de outra classe sem termos que ter uma instância dessa classe como é o caso de composição. Utilizando o Reflect.apply(Aviao.prototype.voa, this, []);

Wordpress
----------------------------------------------------
Poedit.net => para realizar as traduções do tema do wordpress

Ruby
----------------------------------------------------
".abs" => metodo absoluto que retorna um valor sem sinal
"<<" => atribui um valor na posição final do array
"strip" => limpa valores ou espacos em branco no inicio e fim de uma string
"def nome (parametros)" => declara uma função com parametro ou não
"#{}" => interpolacao de string ex.: puts "Meu nome é #{nome}"
"unless" => é um if ao contrario ou negação de uma afirmação
"Rand" => obter números aleatorios em determinada faixa ou 0 e 1 padrão
require_relative "nome_do_arquivo" => funcao que invoca um arquivo no mesmo diretorio do arquivo que está sendo executado
Assim como existe a instrução require_relative existem também a require. Ela busca em uma lista de diretórios específicos pelo arquivo mencionado. Por exemplo, podemos usar ela para carregar a biblioteca padrão de acesso HTTP:
	require "net/http"
	require "uri"
"uri" => URI.parse("http://www.casadocodigo.com.br")
"Net::HTTP.get_print(uri)"
"include? variavel" => Verifica se em determinada linha ou array encontra-se o elemento procurado
"index" => retorna a posição do elemento (coluna)
each_with_index do |variavel com a linha, index|
"join" => junta todos os elementos em de um array em um só: array.join(",")
array.dup => ele duplica o array origem para um novo array.

Em Ruby, tudo que não é nulo nem falso é considerado verdadeiro.
Array passado como parametro eles são referencias ou apontados ao array origem
O ::attr_accessor:: cria na verdade dois métodos. Um para alterar e outro para ler o valor de um atributo. Como ler um atributo diretamente de dentro de uma classe? Através do uso de um "@"
Além do attr_accessor existem também o attr_reader, que fornece somente um leitor, e o attr_writer, que disponibiliza somente o método de escrita.
Recursão é o ato de uma função chamar ela mesma. Base da recursão é o critério onde essa recursão para, caso contrário ela executaria indeterminadamente - o que poderia causar um estouro da pilha de execução.

Docker
----------------------------------------------------
1) Instalar o pacote docker.io: sudo apt-get -y install docker.io
2) Para rodar o docker automaticamente quando o Ubuntu inicia: sudo update-rc.d docker defaults
3) Roda o docker (se não tiver rodando ainda): sudo service docker start
4) Teste a instalação do docker: sudo docker run hello-world

Todas as imagens vem do docker hub

docker images: lista toda as imagens, como seus nomes criados aleatoriamente ou não,
docker run: cria os containers,
docker pull: faz o download de imagens,
docker ps: acompanha os containers em execução.
Docker pull "nome_da_imagem "=> Irá fazer o download da imagem direto do hub
Docker Images => lista todas as imagens já baixadas
docker run --name "nome_do_container" -e parametro_que_seta_variaveis_para_o_container -d (opção para rodar em background) "nome_da_imagem"
docker run --name blog-alura --link "nome_do_container":"nome_da_imagem" -e WORDPRESS_DB_PASSWORD=teste123 -p "porta_host:porta_container" -d wordpress
docker exec -i -t "nome do container" bash : criar uma interatividade com o container via terminal
docker run -it "nome da imagem" bash : Faz o mesmo do item acima
docker ps: lista os containers em execução
docker ps -a: lista todos os containers criados
docker rm [id] / docker rm [nome]: remove um container criado
docker rm $(docker ps -qa): Remove vários containers de uma vez
docker stop [nome]: Parar um container em execução
docker rmi [nome] / docker rmi [id]: Remove uma imagem criada

GIT
----------------------------------------------------
"git clone 'urldorepositorio' " => clona a versão master do repositorio do projeto.
"git tag" => listamos todas as "versões" existentes no repositorio.
"git checkout 'branch'" => muda para outra branch do repositório.
	* "git checkout -b 'branch'" => cria uma nova branch e muda para ela.
	* "git checkou -t 'branch_remota'" => copia a branch remota para local, muda para e atualiza.
	* "git checkout 'arquivo'" => descartar todas as alterações que estão no "Working Directory" de um determinado arquivo e retorna para HEAD.
	* "git checkout 'tag'" => mudar a versão do repositorio para o escolhido.
	* "git checkout 'branch' 'arquivo'" => copia o arquivo da branch q deseja para a branch atual e coloca no status de index pronto para o commit.
	* "git checkout -- 'arquivo'" => Essa notação de dois hífens -- indica que os parâmetros seguintes serão todos nomes de arquivos, permitindo que restauremos o arquivo ao estado original.
"git diff 'tag1' 'tag2" => compara a diferença entre as versões do repositorio.
"git blame 'arquivo'" => funcionalidade onde podemos consultar quem foi o autor de cada linha de um arquivo. Para sair do blame, basta apertar a tecla q
"git init" => indica a pasta como repositório.
"git ls-files" => verifica quais os arquivos que pertencem ao nosso repositório.
"git status" => verifica o estatdo dos arquivos
"git add 'arquivo'" => adiciona o arquivo para "track" pelo git
"git add -i" => mais recomendado quando temos um número muito grande de alterações a serem adicionadas ao index e também um grande número de alterações que não gostaríamos de adicionar ao index. O modo interativo inclusive permite que adicionemos seletivamente trechos de um arquivo, deixando algumas modificações de fora mesmo estando no mesmo arquivo, com a opção patch.
"git commit -m "mensagem aqui"" => enviar as alteracoes feitas no(s) arquivo(s).
	* "-a" => inclui imediatamente no commit todos os arquivos modificados ou removidos! Porém, ela não adiciona os arquivos novos. Podemos combinar a opção de mensagem com git commit -a -m 'Mensagem de commit' para não precisar escrever a mensagem no editor padrão do console.
"git push 'alias do repositorio' 'branch'" => para subir todas as alterações para o servidor de arquivo remoto em uma determinada branch.
	* Outra alternativa é utilizar, no primeiro push, a opção -u ou --set-upstream. Ela atrela a branch remota à local, fazendo com que não seja mais necessário passar como parâmetros a origem e a branch no comando push, que fica então assim: git push.
	* "git push -d 'repositorio' 'branch'" => apaga uma branch remota outra opção "git push 'repositorio' :'branch'"
"git remote add 'alias para repositorio' 'url do repositorio criado'" => para adicionar o repositorio remoto ao local adotar padrão "origin" para o alias.
"git log" => para ver todas os commits no repositorio
"git whatchanged" => a mesma coisa que o git log porém os arquivos que foram alterados. Ao executarmos o comando git whatchanged -p é possível visualizar quais as linhas que foram modificadas em cada commit do nosso projeto. Obs: também é possível utilizarmos git log -p, que imprime também os commits nos quais não houve modificação.
"git branch" => lista todas as branchs do repositório.
	* "git branch 'nome_branch'" => cria uma nova branch no repositório.
	* "git branch -r" => listas todas as branch do repositório remoto.
	* "git branch -t 'branch' 'branch remota'" => copia a branch remota para local.
	* "git branch -d" => este comando remove uma branch, porém somente se ela estiver sincronizada com outra. Senão, é necessário forçar com a opção -D.
	* "git branch -a" => listas as branch locais e remotas
"git pull 'nome repositorio' 'branch'" => atualiza a versão do repositório local com remoto.
"git fetch 'repositorio'" => Este comando verifica todas as atualizações que foram realizadas no repositório remoto e traz para a maquina. Mas elas não são aplicadas e precisam de um merge.
"git rebase 'branch'" => copia os commits de uma branch para outra no caso atualizar sua branch com a master.
"git merge 'branch'" => leva todos os commits de uma branch para outra.
"git reset HEAD 'arquivo'" => Caso o arquivo esteja no estado Index e deseja retorna para Working Directory.
"git stash" => permite guardar as alterações nos estados (Working Directory, Index) em uma área especial, de onde podemos recuperá-los depois.
	* "git stash pop" => recuperar o ultimo stash salvo na lista de stash.
	* "git stash list" =>  lista todos os stashes salvos no momento com o comando git stash.
	* "git stash pop stash@{id}" => recupera um stash especifico.
	* "git stash apply" => recuperar o determinado stash sem remover da lista
	* "git stash drop" => Este comando faz com que o último estado salvo seja apagado. Também podemos utilizar o nome de cada elemento do stash para remover algum estado que não seja o último. Por fim, se quisermos excluir todos os estados, podemos utilizar o comando git stash clear.
"git reset 'pnultimo hash'" => desfaz o ultimo commit e retorna para estado do pnultimo hash.
	* "git reset --hard" => Com este comando, as alterações são removidas do histórico local de commits e também tanto do index quanto do working directory, permanentemente.
	* "git reset --soft" => Com este comando, as alterações são removidas do histórico local de commits, mas não são removidas do index.
	* "git reset --hard HEAD~1" => Usando esse comando, descartamos definitivamente as mudanças feitas no último commit.
"git revert -n [hash_do_commit]" => reverte commits antigos preservando os atuais. A opção "-n", para que as alterações sejam revertidas e adicionadas ao nosso Working Directory e Index. É necessário que o Working Directory e o Index estejam "limpos", ou as alterações atuais serão descartadas.
"git show 'hash'" => visualiza as alterações realizadas no commit
"git cherry-pick 'hash'" => copia um commit especifico para sua branch.
	* "-n" => A opção -n ou --no-commit permite que recuperemos as alterações de um dado commit sem precisar inseri-lo no histórico local.

Encontrando o bug ao meio de muitos commits
git bisect start
git bisect bad HEAD
git biscet good 'hash bom'
Acima, iniciamos uma sessão de "bisect" e marcamos o commit HEAD como "bad" (ruim), ou seja, indicamos que ele contém o bug o qual queremos encontrar o momento em que foi introduzido. Agora que o Git sabe qual commit funciona e qual não funciona, ele automaticamente faz o checkout de um commit intermediário para que possamos verificar se funciona.

"git bisect bad" => para afirmar se aquele commit escolhido pelo git ainda está com o bug
"git bisect good" => para afirmar que aquele commit escolhido pelo git está okay.

Git possui 3 estados: Working Directory, Index e Head.
Ao digitarmos HEAD~ seguido de um número inteiro n, será feita uma referência ao n-ésimo commit anterior ao HEAD. Por exemplo, HEAD~1, faz referência ao penúltimo commit e HEAD~2, ao antepenúltimo. No caso específico do penúltimo commit, também pode-se referenciá-lo utilizando o atalho HEAD^.

Opção gráfica para o GIT: http://git-cola.github.io/downloads.html

Grunt
----------------------------------------------------
"npm init" => Por uma questão de organização, o Node.js pode tomar nota de todos os módulos de que sua aplicação depende num arquivo chamado package.json. Podemos criá-lo através do próprio npm executando o seguinte comando dentro da pasta projeto.
"npm install grunt --save-dev" => O comando baixará a versão mais atual do Grunt gravando-a dentro da pasta node_modules. Esta pasta guarda todos os módulos usado pelo seu projeto. O parâmetro --save-dev adiciona a dependência no arquivo package.json
"npm install grunt-cli -g" => É importante que você tenha permissão de administrador já que estamos instalando o módulo globalmente através do parâmetro -g. Este módulo nos permite chamar o comando 'grunt' em qualquer local em nosso terminal.
"npm install" => O comando lerá de package.json todos os módulos de que sua aplicação depende baixando-os todos de uma só vez, levando em consideração cada versão utilizada.
"npm install grunt-contrib-copy --save-dev" instala o plugin grunt-contrib-copy
"npm install grunt-contrib-clean --save-dev" => instala o plugin grunt-contrib-clean
"grunt.registerTask('dist', ['clean', 'copy']);" => registrar novas tasks que chamam outras na sequência que definirmos. Repare que a função acima recebe como primeiro parâmetro o nome da nossa task. O segundo é um array com o nome de todas as tasks já configuradas pelo Grunt. A ordem é importante, pois a primeira será executada antes da segunda e por ai vai.

CONCATENACAO E MINIFICAÇÃO
npm install grunt-contrib-concat --save-dev
npm install grunt-contrib-uglify --save-dev
npm install grunt-contrib-cssmin --save-dev
npm install grunt-usemin --save-dev
O grunt-usemin é um plugin que facilita incrivelmente a configuração das tasks envolvidas no processo de merge e minificação. Só precisamos configurar sua task para que ela gere automaticamente os parâmetros de configuração para os três plugins que vimos anteriormente.
npm install grunt-rev --save-dev => responsável em renomear os arquivos adicionando seu hash como prefixo
npm install grunt-contrib-coffee --save-dev => compilador de coffescript
npm install grunt-contrib-less --save-dev => compilador de less
npm install grunt-contrib-watch --save-dev => executaremos automaticamente toda vez que novos arquivos forem criados ou modificados através da task watch.
npm install grunt-contrib-jshint --save-dev => validação do codigo JS sem a necessidade de um navegador ou coisa do tipo.
npm install grunt-browser-sync --save-dev => sincronização de paginas em varios dispositivos.


O arquivo Gruntfile.js é onde configuramos tarefas (tasks). Todo o código ficará envolto por uma função wrapper que recebe como parâmetro o objeto do Grunt.

Gulp
----------------------------------------------------
"npm install gulp@3.9.0 --save-dev" => instala o gulp no projeto
"gulp.src('folder ou file')" => esse comando faz é gerar um fluxo de leitura para a origem projeto/src/img e todos os seus arquivos.
"gulp.dest('folder ou file')"" => esse comoando faz é gerar um fluxo de gravação para o destino e todos os seus arquivos.
"npm install gulp-imagemin@2.3.0 --save-dev" => baixar o modulo de otimização de imagem.
"npm run gulp 'nome da tarefa'" => executa determinada tarefa do gulp.
"npm install gulp-clean@0.3.1 --save-dev" => apagar arquivos ou pasta

O Gulp é uma ferramenta de build totalmente feita em JavaScript tornando-a atrativa no mundo front-end, especialmente para nosso projeto. Porém, para que funcione, precisamos do Node.js instalado em nosso máquina.

Outra vantagem de salvarmos nossas dependências em package.json é que você pode compartilhar seu projeto sem a pasta node_modules, que deve ser baixada novamente através do comando npm install, sem qualquer parâmetro. O comando lerá do package.json todos os módulos de que sua aplicação depende baixando-os todos de uma só vez, levando em consideração cada versão utilizada.